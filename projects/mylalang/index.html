<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="ie=edge">
<title>Mylalang - apiercey.github.io</title>
<meta name=viewport content="width=device-width,initial-scale=1">
<link rel=icon href=/favicon.png>
<link rel=stylesheet href=/css/style.min.4b2bfb3701049fe0da3e8d6b9d15186ba1dc7e294f0be3e2bca21bb8a330f5dd.css>
<meta name=description content="Mylalang is a LISP implemented in Rust.">
<meta property="og:title" content="Mylalang">
<meta property="og:type" content="website">
<meta property="og:url" content="/projects/mylalang/">
<meta property="og:image" content="/images/nasa-space.jpg">
<meta property="og:description" content="Mylalang is a LISP implemented in Rust.">
<meta name=twitter:card content="summary">
<meta name=twitter:site content="@example">
<meta name=twitter:creator content="@example">
<link rel=preconnect href=https://fonts.gstatic.com>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap" rel=stylesheet>
</head>
<body class="page page-default-single">
<div id=wrapper class=wrapper>
<div class=header>
<a class=header-logo href=/>apiercey.github.io</a>
<div class=menu-main>
<ul>
<li class=menu-item-about>
<a href=/pages/about/>About</a>
</li>
<li class=menu-item-blog>
<a href=/posts/>Blog</a>
</li>
<li class=menu-item-projects>
<a href=/projects/>Projects</a>
</li>
<li class=menu-item-articles>
<a href=/articles/>Articles</a>
</li>
</ul>
</div>
</div>
<div class=intro>
<h1>Mylalang<span class=dot>.</span></h1>
<img src=/images/nasa-space.jpg>
</div>
<div class=content>
<h1 id=mylalang>Mylalang</h1>
<p><a href=https://github.com/APiercey/mylalang>Mylalang</a> is a LISP implemented in Rust.</p>
<h2 id=content>Content</h2>
<ul>
<li><a href=#content>Content</a></li>
<li><a href=#usage>Usage</a>
<ul>
<li><a href=#interactive-repl>Interactive REPL</a></li>
<li><a href=#interpreter>Interpreter</a></li>
</ul>
</li>
<li><a href=#types>Types</a></li>
<li><a href=#arithmetic-operators>Arithmetic Operators</a>
<ul>
<li><a href=#list-processing>List Processing</a></li>
</ul>
</li>
<li><a href=#relational-operators>Relational Operators</a></li>
<li><a href=#comments>Comments</a></li>
<li><a href=#binding-values>Binding values</a></li>
<li><a href=#functions>Functions</a>
<ul>
<li><a href=#named-functions>Named Functions</a></li>
<li><a href=#anonymous-functions>Anonymous Functions</a></li>
<li><a href=#local-binding>Local Binding</a></li>
<li><a href=#function-overloading>Function Overloading</a></li>
</ul>
</li>
<li><a href=#aliasing>Aliasing</a></li>
<li><a href=#inspecting>Inspecting</a></li>
<li><a href=#the--do--function>The <code>do</code> Function</a></li>
<li><a href=#conditionals>Conditionals</a></li>
<li><a href=#files>Files</a>
<ul>
<li><a href=#reading-files>Reading Files</a></li>
<li><a href=#importing>Importing</a></li>
</ul>
</li>
<li><a href=#recursion-and-loops>Recursion and Loops</a></li>
<li><a href=#the--cons--function>The <code>cons</code> Function</a></li>
<li><a href=#the--list--function>The <code>list</code> Function</a>
<ul>
<li><a href=#----operator><code>:</code> Operator</a></li>
</ul>
</li>
<li><a href=#the-----operator-and-the--apply--function>The <code>&</code> Operator and the <code>apply</code> Function</a></li>
<li><a href=#evaluating-code>Evaluating Code</a>
<ul>
<li><a href=#complex-example>Complex Example</a></li>
</ul>
</li>
<li><a href=#native-functions>Native functions</a>
<ul>
<li><a href=#-foldl-><code>foldl</code></a></li>
<li><a href=#-foldr-><code>foldr</code></a></li>
<li><a href=#-min-><code>min</code></a></li>
<li><a href=#-max-><code>max</code></a></li>
<li><a href=#-double-><code>double</code></a></li>
<li><a href=#-map-><code>map</code></a></li>
</ul>
</li>
</ul>
<p>Table of contents generated with markdown-toc</p>
<h2 id=usage>Usage</h2>
<p>Firstly, clone the repository to a local directory</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>git clone git@github.com:APiercey/mylalang.git
<span class=nb>cd</span> mylalang
</code></pre></div><p>Mylalang comes with two binaries: an interactive REPL and a interpreter.</p>
<h3 id=interactive-repl>Interactive REPL</h3>
<p>The REPL can be started by running:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cargo run --bin imy
</code></pre></div><h3 id=interpreter>Interpreter</h3>
<p>The REPL can be started by running:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cargo run --bin imy
</code></pre></div><h2 id=types>Types</h2>
<p>Only primitive types exist in Mylalang. Constructing types does not exist.</p>
<ul>
<li><code>Integer</code>s written like <code>1</code> or <code>1042</code>.</li>
<li><code>Float</code>s written like <code>89.353</code>.</li>
<li><code>String</code>s written like &ldquo;This is a string!&rdquo; or &ldquo;Hello, world.&rdquo;</li>
<li><code>Null</code> written as <code>nil</code>.</li>
<li><code>Array</code>s written as <code>[]</code> contain other types, written like <code>[2 23 88]</code> or <code>["mixed list" 823.45 "containing different" 90 "types" nil]</code></li>
<li><code>List</code>s written as <code>()</code> contain other types and form the syntax of the language. Can be constructed using the <code>list</code> function.</li>
<li><code>Function</code>s written as <code>(fn [arg1 arg2 ...argN])</code>. More about this under the functions section.</li>
<li><code>Boolean</code> values are natural booleans, written as <code>true</code> or <code>false</code></li>
</ul>
<h2 id=arithmetic-operators>Arithmetic Operators</h2>
<p>Addition</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nb>+ </span><span class=mi>1</span> <span class=mi>2</span><span class=p>)</span>
<span class=nv>=&gt;</span> <span class=mi>3</span>
</code></pre></div><p>Subtraction</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nb>- </span><span class=mi>7</span> <span class=mi>2</span><span class=p>)</span>
<span class=nv>=&gt;</span> <span class=mi>5</span>
</code></pre></div><p>Multiplication</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nb>* </span><span class=mi>10</span> <span class=mi>2</span><span class=p>)</span>
<span class=nv>=&gt;</span> <span class=mi>20</span>
</code></pre></div><p>Division</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nb>/ </span><span class=mi>2</span> <span class=mi>10</span><span class=p>)</span>
<span class=nv>=&gt;</span> <span class=mi>20</span>
</code></pre></div><h3 id=list-processing>List Processing</h3>
<p>All operators work against their arguments as lists, reducing to a result:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nb>+ </span><span class=mi>1</span> <span class=mi>2</span> <span class=mi>3</span> <span class=mi>4</span> <span class=mi>5</span><span class=p>)</span>
<span class=nv>=&gt;</span> <span class=mi>15</span>

<span class=p>(</span><span class=nb>- </span><span class=mi>1</span> <span class=mi>2</span> <span class=mi>3</span> <span class=mi>4</span> <span class=mi>5</span><span class=p>)</span>
<span class=nv>=&gt;</span> <span class=mi>-13</span>
</code></pre></div><h2 id=relational-operators>Relational Operators</h2>
<p>Equality</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nb>= </span><span class=mi>1</span> <span class=mi>1</span><span class=p>)</span>
<span class=nv>=&gt;</span> <span class=nv>true</span>

<span class=p>(</span><span class=nb>= </span><span class=mi>2</span> <span class=mi>1</span><span class=p>)</span>
<span class=nv>=&gt;</span> <span class=nv>false</span>
</code></pre></div><p>Greater than</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nb>&gt; </span><span class=nv>nil</span> <span class=mi>1</span><span class=p>)</span>
<span class=nv>=&gt;</span> <span class=nv>false</span>

<span class=p>(</span><span class=nb>&gt; </span><span class=mi>1</span> <span class=nv>nil</span><span class=p>)</span>
<span class=nv>=&gt;</span> <span class=nv>true</span>
</code></pre></div><p>Less than</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nb>&lt; </span><span class=mi>1</span> <span class=nv>nil</span><span class=p>)</span>
<span class=nv>=&gt;</span> <span class=nv>false</span>

<span class=p>(</span><span class=nb>&lt; </span><span class=nv>nil</span> <span class=mi>1</span><span class=p>)</span>
<span class=nv>=&gt;</span> <span class=nv>true</span>
</code></pre></div><p>Greater than or equal to</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nb>&gt;= </span><span class=mi>1</span> <span class=mi>1</span><span class=p>)</span>
<span class=nv>=&gt;</span> <span class=nv>true</span>

<span class=p>(</span><span class=nb>&gt;= </span><span class=mi>2</span> <span class=mi>1</span><span class=p>)</span>
<span class=nv>=&gt;</span> <span class=nv>true</span>

<span class=p>(</span><span class=nb>&gt;= </span><span class=mi>1</span> <span class=mi>2</span><span class=p>)</span>
<span class=nv>=&gt;</span> <span class=nv>false</span>
</code></pre></div><p>Less then or equal to</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nb>&lt;= </span><span class=mi>1</span> <span class=mi>1</span><span class=p>)</span>
<span class=nv>=&gt;</span> <span class=nv>true</span>

<span class=p>(</span><span class=nb>&lt;= </span><span class=mi>1</span> <span class=mi>2</span><span class=p>)</span>
<span class=nv>=&gt;</span> <span class=nv>true</span>

<span class=p>(</span><span class=nb>&lt;= </span><span class=mi>2</span> <span class=mi>1</span><span class=p>)</span>
<span class=nv>=&gt;</span> <span class=nv>false</span>
</code></pre></div><h2 id=comments>Comments</h2>
<p>Comments start with <code>;</code></p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=c1>; This is a comment!</span>

<span class=c1>; This code does not execute</span>
<span class=c1>; (def a &#34;123&#34;)</span>

<span class=nv>a</span>

<span class=nv>thread</span> <span class=ss>&#39;main</span><span class=o>&#39;</span> <span class=nv>panicked</span> <span class=nv>at</span> <span class=o>&#39;</span><span class=s>&#34;a&#34;</span> <span class=nv>does</span> <span class=nb>not </span><span class=nv>exist</span> <span class=nv>within</span> <span class=nv>this</span> <span class=nv>scope</span>

<span class=c1>; oops :)</span>
</code></pre></div><h2 id=binding-values>Binding values</h2>
<p>The <code>def</code> keyword allows bind a value (and functions but more on that later) to a name:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=k>def </span><span class=nv>a</span> <span class=mi>23</span><span class=p>)</span>
<span class=nv>=&gt;</span> <span class=nv>&lt;#def</span> <span class=s>&#34;a&#34;</span><span class=nv>&gt;</span>

<span class=p>(</span><span class=k>def </span><span class=nv>b</span> <span class=mi>2</span><span class=p>)</span>

<span class=p>(</span><span class=nb>+ </span><span class=nv>a</span> <span class=nv>b</span><span class=p>)</span>
<span class=nv>=&gt;</span> <span class=mi>23</span>
</code></pre></div><h2 id=functions>Functions</h2>
<p>In Mylalang, functions are a primitive type. They can be bound to a name and used as a value. Through this, the language supports both anonymous and named functions.</p>
<h3 id=named-functions>Named Functions</h3>
<p>The <code>def</code> keyword can be used to bind a function to a name</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=k>def </span><span class=nb>double </span><span class=p>(</span><span class=k>fn </span><span class=p>[</span><span class=nv>a</span><span class=p>]</span> <span class=nv>a</span> <span class=nb>* </span><span class=mi>2</span><span class=p>))</span>
<span class=nv>=&gt;</span> <span class=nv>&lt;#def</span> <span class=s>&#34;double&#34;</span><span class=nv>&gt;</span>

<span class=p>(</span><span class=nb>double </span><span class=mi>2</span><span class=p>)</span>
<span class=nv>=&gt;</span> <span class=mi>4</span>
</code></pre></div><p>Functions can take multiple parameters</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=k>def </span><span class=nv>greet</span> <span class=p>(</span><span class=k>fn </span><span class=p>[</span><span class=nv>firstname</span> <span class=nv>lastname</span><span class=p>]</span> <span class=p>(</span><span class=nb>+ </span><span class=s>&#34;Hello &#34;</span> <span class=nv>firstname</span> <span class=s>&#34; &#34;</span> <span class=nv>lastname</span><span class=p>)))</span>
<span class=nv>=&gt;</span> <span class=nv>&lt;#def</span> <span class=s>&#34;greet&#34;</span><span class=nv>&gt;</span>

<span class=p>(</span><span class=nf>greet</span> <span class=s>&#34;John&#34;</span> <span class=s>&#34;Travolta&#34;</span><span class=p>)</span>
<span class=nv>=&gt;</span> <span class=nv>Hello</span> <span class=nv>John</span> <span class=nv>Travolta</span>
</code></pre></div><h3 id=anonymous-functions>Anonymous Functions</h3>
<p>Anonymous functions are called without binding it to a name. An example makes this easier to explain</p>
<p>The function below doubles a given number:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=k>fn </span><span class=p>[</span><span class=nv>a</span><span class=p>]</span> <span class=p>(</span><span class=nb>* </span><span class=mi>2</span><span class=p>))</span>
<span class=nv>=&gt;</span> <span class=nv>&lt;#anonfunc</span> <span class=p>[[</span><span class=nv>&lt;#def</span> <span class=s>&#34;a&#34;</span><span class=nv>&gt;</span><span class=p>]]</span><span class=nv>&gt;</span>
</code></pre></div><p>The return value is a function. Like this, it&rsquo;s a bit useless but it provides the foundation of using functions as values. They can be called immediately or passed as a function:</p>
<p>Executing an anonymous function</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>((</span><span class=k>fn </span><span class=p>[</span><span class=nv>fruit</span><span class=p>]</span> <span class=p>(</span><span class=nb>+ </span><span class=s>&#34;My favorite fruit is &#34;</span> <span class=nv>fruit</span><span class=p>))</span> <span class=s>&#34;Banana&#34;</span><span class=p>)</span>
<span class=nv>=&gt;</span> <span class=nv>My</span> <span class=nv>favorite</span> <span class=nv>fruit</span> <span class=nv>is</span> <span class=nv>Banana</span>
</code></pre></div><p>Comparing to its named counterpart</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=k>def </span><span class=nv>favfruit</span> <span class=p>(</span><span class=k>fn </span><span class=p>[</span><span class=nv>fruit</span><span class=p>]</span> <span class=p>(</span><span class=nb>+ </span><span class=s>&#34;My favorite fruit is &#34;</span> <span class=nv>fruit</span><span class=p>)))</span>
<span class=nv>=&gt;</span> <span class=nv>&lt;#def</span> <span class=s>&#34;favfruit&#34;</span><span class=nv>&gt;</span>

<span class=p>(</span><span class=nf>favfruit</span> <span class=s>&#34;Banana&#34;</span><span class=p>)</span>
<span class=nv>=&gt;</span> <span class=nv>My</span> <span class=nv>favorite</span> <span class=nv>fruit</span> <span class=nv>is</span> <span class=nv>Banana</span>
</code></pre></div><p>Passing functions as values</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=k>def </span><span class=nb>double </span><span class=p>(</span><span class=k>fn </span><span class=p>[</span><span class=nv>a</span><span class=p>]</span> <span class=p>(</span><span class=nb>* </span><span class=nv>a</span> <span class=mi>2</span><span class=p>)))</span>
<span class=nv>=&gt;</span> <span class=nv>&lt;#def</span> <span class=s>&#34;double&#34;</span><span class=nv>&gt;</span>

<span class=p>(</span><span class=k>def </span><span class=nv>applyfunc</span> <span class=p>(</span><span class=k>fn </span><span class=p>[</span><span class=nv>f</span> <span class=nv>a</span><span class=p>]</span> <span class=p>(</span><span class=nb>+ </span><span class=s>&#34;The value of the applied function is: &#34;</span> <span class=p>(</span><span class=nf>f</span> <span class=nv>a</span><span class=p>)))</span>
<span class=nv>=&gt;</span> <span class=nv>&lt;#def</span> <span class=s>&#34;applyfunc&#34;</span><span class=nv>&gt;</span>

<span class=p>(</span><span class=nf>applyfunc</span> <span class=nb>double </span><span class=mi>21</span><span class=p>)</span>
<span class=nv>=&gt;</span> <span class=nv>The</span> <span class=nv>value</span> <span class=nv>of</span> <span class=nv>the</span> <span class=nv>applied</span> <span class=nv>function</span> <span class=nv>is</span><span class=err>:</span> <span class=mi>42</span>
</code></pre></div><h3 id=local-binding>Local Binding</h3>
<p>It is possible to bind local scoped variables to a function using the <code>let</code> keyword. This keyword functions the same as <code>def</code> but can only be used within a function.</p>
<p><code>let</code> is a function which takes multiple arguments. The first is <code>list</code> of name and value pairs and binds the name in the first position to a value in the second position of each pair in the list.</p>
<p>The remaining arguments can be function calls with the last function to return a value. This is used when you want to execute side effects or inspect a result.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=o>#</span> <span class=nv>This</span> <span class=nv>example</span> <span class=nv>needs</span> <span class=nv>to</span> <span class=nv>be</span> <span class=nv>compressed</span> <span class=nb>into </span><span class=nv>a</span> <span class=nv>single</span> <span class=nv>line</span> <span class=nv>to</span> <span class=nv>execute</span> <span class=nv>correctly</span> <span class=nv>in</span> <span class=nv>the</span> <span class=nv>REPL.</span>

<span class=p>(</span><span class=k>def </span><span class=nv>shifter</span> <span class=p>(</span><span class=k>fn </span><span class=p>[</span><span class=nv>i</span><span class=p>]</span>
  <span class=p>(</span><span class=k>let </span><span class=p>[</span><span class=nv>x</span> <span class=p>(</span><span class=nb>* </span><span class=nv>i</span> <span class=nv>i</span><span class=p>)</span>
        <span class=nv>y</span> <span class=p>(</span><span class=nb>+ </span><span class=nv>i</span> <span class=nv>i</span><span class=p>)</span>
        <span class=nv>z</span> <span class=p>(</span><span class=k>if </span><span class=p>(</span><span class=nb>&gt; </span><span class=nv>x</span> <span class=mi>50</span><span class=p>)</span> <span class=p>(</span><span class=nb>- </span><span class=nv>x</span> <span class=nv>y</span><span class=p>)</span> <span class=p>(</span><span class=nb>+ </span><span class=nv>x</span> <span class=nv>y</span><span class=p>))]</span>
    <span class=p>(</span><span class=nb>+ </span><span class=s>&#34;Final value is &#34;</span> <span class=nv>z</span><span class=p>))))</span>
    
<span class=nv>=&gt;</span> <span class=nv>&lt;#def</span> <span class=s>&#34;shifter&#34;</span><span class=nv>&gt;</span>
</code></pre></div><p>In the example above, <code>x</code> equals the value if <code>i</code> multiplied by <code>i</code>.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nf>shifter</span> <span class=mi>23</span><span class=p>)</span>
<span class=nv>=&gt;</span> <span class=nv>Final</span> <span class=nv>value</span> <span class=nv>is</span> <span class=mi>483</span>
</code></pre></div><h3 id=function-overloading>Function Overloading</h3>
<p>It&rsquo;s possible to bind multiple functions to the same name if they accept different parameters.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=k>def </span><span class=nv>greeter</span> <span class=p>(</span><span class=k>fn </span><span class=p>[</span><span class=nv>name</span><span class=p>]</span> 
  <span class=p>(</span><span class=k>let </span><span class=p>[</span><span class=nv>greeting</span> <span class=p>(</span><span class=nb>+ </span><span class=s>&#34;Hello &#34;</span> <span class=nv>name</span><span class=p>)]</span>
    <span class=p>(</span><span class=nf>inspect</span> <span class=nv>greeting</span><span class=p>))))</span>
<span class=nv>=&gt;</span> <span class=nv>&lt;#def</span> <span class=s>&#34;greeter&#34;</span><span class=nv>&gt;</span>
  
<span class=p>(</span><span class=k>def </span><span class=nv>greeter</span> <span class=p>(</span><span class=k>fn </span><span class=p>[</span><span class=nv>first_name</span> <span class=nv>last_name</span><span class=p>]</span>
  <span class=p>(</span><span class=k>let </span><span class=p>[</span><span class=nv>greeting</span> <span class=p>(</span><span class=nb>+ </span><span class=s>&#34;Hello &#34;</span> <span class=nv>first_name</span> <span class=s>&#34; &#34;</span> <span class=nv>last_name</span><span class=p>)]</span>
    <span class=p>(</span><span class=nf>inspect</span> <span class=nv>greeting</span><span class=p>))))</span>
<span class=nv>=&gt;</span> <span class=nv>&lt;#def</span> <span class=s>&#34;greeter&#34;</span><span class=nv>&gt;</span>
  
<span class=p>(</span><span class=k>def </span><span class=nv>greeter</span> <span class=p>(</span><span class=k>fn </span><span class=p>[</span><span class=nv>salutation</span> <span class=nv>first_name</span> <span class=nv>last_name</span><span class=p>]</span>
  <span class=p>(</span><span class=k>let </span><span class=p>[</span><span class=nv>greeting</span> <span class=p>(</span><span class=nb>+ </span><span class=s>&#34;Hello &#34;</span> <span class=nv>salutation</span> <span class=s>&#34;. &#34;</span> <span class=nv>first_name</span> <span class=s>&#34; &#34;</span> <span class=nv>last_name</span><span class=p>)]</span>
    <span class=p>(</span><span class=nf>inspect</span> <span class=nv>greeting</span><span class=p>))))</span>
<span class=nv>=&gt;</span> <span class=nv>&lt;#def</span> <span class=s>&#34;greeter&#34;</span><span class=nv>&gt;</span>

<span class=p>(</span><span class=nf>greeter</span> <span class=s>&#34;Alan&#34;</span><span class=p>)</span>
<span class=nv>=&gt;</span> <span class=nv>Hello</span> <span class=nv>Alan</span>

<span class=p>(</span><span class=nf>greeter</span> <span class=s>&#34;Alan&#34;</span> <span class=s>&#34;Turing&#34;</span><span class=p>)</span>
<span class=nv>=&gt;</span> <span class=nv>Hello</span> <span class=nv>Alan</span> <span class=nv>Turing</span>

<span class=p>(</span><span class=nf>greeter</span> <span class=s>&#34;Dr&#34;</span> <span class=s>&#34;Alan&#34;</span> <span class=s>&#34;Turing&#34;</span><span class=p>)</span>
<span class=nv>=&gt;</span> <span class=nv>Hello</span> <span class=nv>Dr.</span> <span class=nv>Alan</span> <span class=nv>Turing</span>
</code></pre></div><p>This allows to build boundaries in a very convenient way, particularly with recursion.</p>
<h2 id=aliasing>Aliasing</h2>
<p>Because all types - including functions - are just values, it is possible to bind a name to <em>another</em> name using <code>def</code>.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=k>def </span><span class=nv>hey</span> <span class=p>(</span><span class=k>fn </span><span class=p>[]</span> <span class=p>(</span><span class=nf>inspect</span> <span class=s>&#34;Hey&#34;</span><span class=p>)))</span>
<span class=nv>=&gt;</span> <span class=nv>&lt;#def</span> <span class=s>&#34;hey&#34;</span><span class=nv>&gt;</span>

<span class=p>(</span><span class=k>def </span><span class=nv>sayhey</span> <span class=nv>hey</span><span class=p>)</span>
<span class=nv>=&gt;</span> <span class=nv>&lt;#def</span> <span class=s>&#34;sayhey&#34;</span><span class=nv>&gt;</span>

<span class=p>(</span><span class=nf>sayhey</span><span class=p>)</span>
<span class=nv>Hey</span>
<span class=nv>=&gt;</span> <span class=nv>Hey</span>

<span class=p>(</span><span class=k>def </span><span class=nv>no_i_made_this</span> <span class=s>&#34;A very fancy string&#34;</span><span class=p>)</span>
<span class=nv>=&gt;</span> <span class=nv>&lt;#def</span> <span class=s>&#34;no_i_made_this&#34;</span><span class=nv>&gt;</span>

<span class=p>(</span><span class=nf>inspect</span> <span class=nv>no_i_made_this</span><span class=p>)</span>
<span class=nv>=&gt;</span> <span class=s>&#34;A very fancy string&#34;</span>
</code></pre></div><h2 id=inspecting>Inspecting</h2>
<p>Mylalang lets you inspect a value and pass it through to calling functions.</p>
<p>Inspecting simple results</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nf>inspect</span> <span class=s>&#34;This is an inspection!&#34;</span><span class=p>)</span>

<span class=nv>This</span> <span class=nv>is</span> <span class=nv>an</span> <span class=nv>inspection!</span>
<span class=nv>=&gt;</span> <span class=nv>This</span> <span class=nv>is</span> <span class=nv>an</span> <span class=nv>inspection!</span>
</code></pre></div><p>The output in a REPL shows a printed result and then shows the value of the executed statement.</p>
<p>Using inspect inside a function</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=k>def </span><span class=nv>suspiciousfunction</span> <span class=p>(</span><span class=k>fn </span><span class=p>[</span><span class=nv>a</span><span class=p>]</span>
  <span class=p>(</span><span class=k>let </span><span class=p>[</span><span class=nv>r</span> <span class=p>(</span><span class=nb>* </span><span class=nv>a</span> <span class=nv>a</span><span class=p>)]</span>
    <span class=p>(</span><span class=nf>inspect</span> <span class=p>(</span><span class=nb>+ </span><span class=s>&#34;Result is strange... &#34;</span> <span class=nv>r</span><span class=p>))</span>
    <span class=nv>r</span><span class=p>)))</span>
</code></pre></div><h2 id=the-do-function>The <code>do</code> Function</h2>
<p>The <code>do</code> function lets you execute multiple functions without the need of a <code>let</code> function. It&rsquo;s used when you want to execute side effects but have no need for <code>let</code> local bindings.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=k>def </span><span class=nv>saygarbage</span> <span class=p>(</span><span class=k>fn </span><span class=p>[</span><span class=nv>a</span><span class=p>]</span>
  <span class=p>(</span><span class=k>do </span><span class=p>(</span><span class=nf>inspect</span> <span class=s>&#34;Hello world&#34;</span><span class=p>)</span>
      <span class=p>(</span><span class=nf>inspect</span> <span class=s>&#34;foo bar&#34;</span><span class=p>)</span>
      <span class=nv>a</span><span class=p>)))</span>

<span class=nv>=&gt;</span> <span class=nv>&lt;#def</span> <span class=s>&#34;saygarbage&#34;</span><span class=nv>&gt;</span>
<span class=p>(</span><span class=nf>saygarbage</span> <span class=s>&#34;123&#34;</span><span class=p>)</span>
<span class=nv>Hello</span> <span class=nv>world</span>
<span class=nv>foo</span> <span class=nv>bar</span>
<span class=nv>=&gt;</span> <span class=mi>123</span>
</code></pre></div><h2 id=conditionals>Conditionals</h2>
<p>There are two conditional statements:</p>
<ul>
<li><code>if</code>, which when given a true statement returns (or executes) the left value. When false, the right value.</li>
<li><code>unless</code>, which when given a false statement returns (or executes) the left value. When true, the right value.</li>
</ul>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=k>if </span><span class=p>(</span><span class=nb>&lt; </span><span class=mi>1</span> <span class=mi>10</span><span class=p>)</span> <span class=s>&#34;One is lower than ten&#34;</span> <span class=s>&#34;Something is fishy..&#34;</span><span class=p>)</span>

<span class=nv>=&gt;</span> <span class=nv>One</span> <span class=nv>is</span> <span class=nv>lower</span> <span class=nv>than</span> <span class=nv>ten</span>
</code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nf>unless</span> <span class=p>(</span><span class=nb>= </span><span class=mi>8</span> <span class=mi>8</span><span class=p>)</span> <span class=s>&#34;We&#39;ve broken math&#34;</span> <span class=s>&#34;8 always equals 8&#34;</span><span class=p>)</span>

<span class=nv>=&gt;</span> <span class=mi>8</span> <span class=nv>always</span> <span class=nv>equals</span> <span class=mi>8</span>
</code></pre></div><h2 id=files>Files</h2>
<h3 id=reading-files>Reading Files</h3>
<p>The <code>readfile</code> function will read the contents of a file. The value returned is a string.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=c1>; echo &#34;Hello world&#34; &gt; file.txt</span>

<span class=p>(</span><span class=nf>readfile</span> <span class=s>&#34;file.txt&#34;</span><span class=p>)</span>

<span class=nv>=&gt;</span> <span class=nv>Hello</span> <span class=nv>world</span>
</code></pre></div><h3 id=importing>Importing</h3>
<p>Importing named valued (bound through <code>def</code>) in another file is possible using the <code>import</code> function, which binds the imported functions to named in the local scope.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=o>#</span> <span class=nv>math.my</span>
<span class=p>(</span><span class=k>def </span><span class=nb>double </span><span class=p>(</span><span class=k>fn </span><span class=p>[</span><span class=nv>a</span><span class=p>]</span> <span class=p>(</span><span class=nb>* </span><span class=nv>a</span> <span class=mi>2</span><span class=p>)))</span>

<span class=o>#</span> <span class=nv>main.my</span>
<span class=p>(</span><span class=nb>import </span><span class=s>&#34;math.my&#34;</span><span class=p>)</span>

<span class=nv>=&gt;</span> <span class=nv>&lt;#def</span> <span class=s>&#34;double&#34;</span><span class=nb>&gt; </span>

<span class=p>(</span><span class=nb>double </span><span class=mi>99</span><span class=p>)</span>

<span class=nv>=&gt;</span> <span class=mi>198</span>
</code></pre></div><h2 id=recursion-and-loops>Recursion and Loops</h2>
<p>Recursion is used for looping in Mylang.</p>
<p>Example of a function using recursion create a loop with an exit condition</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=k>def </span><span class=nv>start</span> <span class=mi>0</span><span class=p>)</span>

<span class=p>(</span><span class=k>def </span><span class=nb>inc </span><span class=p>(</span><span class=k>fn </span><span class=p>[</span><span class=nv>i</span><span class=p>]</span> 
  <span class=p>(</span><span class=nb>+ </span><span class=nv>i</span> <span class=mi>1</span><span class=p>)))</span>

<span class=p>(</span><span class=k>def loop </span><span class=p>(</span><span class=k>fn </span><span class=p>[</span><span class=nv>i</span><span class=p>]</span> 
  <span class=p>(</span><span class=k>if </span><span class=p>(</span><span class=nb>&lt;= </span><span class=nv>i</span> <span class=mi>10</span><span class=p>)</span> 
    <span class=p>(</span><span class=k>loop </span><span class=p>(</span><span class=nb>inc </span><span class=p>(</span><span class=nf>inspect</span> <span class=nv>i</span><span class=p>)))</span>
    <span class=p>(</span><span class=nf>inspect</span> <span class=s>&#34;finished&#34;</span><span class=p>))))</span>

<span class=p>(</span><span class=k>loop </span><span class=nv>start</span><span class=p>)</span>
</code></pre></div><h2 id=the-cons-function>The <code>cons</code> Function</h2>
<p>The <code>cons</code> operator is function which constructs a list from another value. An example of its usage is to append a value to a list.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nb>cons </span><span class=s>&#34;This&#34;</span> <span class=p>[</span><span class=s>&#34;is&#34;</span> <span class=s>&#34;my&#34;</span> <span class=s>&#34;list&#34;</span><span class=p>])</span>
<span class=nv>=&gt;</span> <span class=p>[[</span><span class=nv>This</span>, <span class=nv>is</span>, <span class=nv>my</span>, <span class=nv>list</span><span class=p>]]</span>
</code></pre></div><h2 id=the-list-function>The <code>list</code> Function</h2>
<p>The <code>()</code> syntax is literally a list which executes a context. The context being the first item in the list.</p>
<p>For this reason, it is difficult for Mylalang to understand if you want to <em>construct</em> a list or execute a some context, such as a bound function.
The <code>list</code> function solves this issue by creating a list for you.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nb>list </span><span class=mi>1</span> <span class=mi>2</span> <span class=mi>3</span> <span class=mi>5</span> <span class=mi>7</span> <span class=mi>11</span> <span class=mi>13</span><span class=p>)</span>
<span class=nv>=&gt;</span> <span class=p>([</span><span class=mi>1</span>, <span class=mi>2</span>, <span class=mi>3</span>, <span class=mi>5</span>, <span class=mi>7</span>, <span class=mi>11</span>, <span class=mi>13</span><span class=p>])</span>
</code></pre></div><p>Lists can be operated on like any other primitive type.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nf>+</span>
  <span class=p>(</span><span class=nb>list </span><span class=mi>1</span> <span class=mi>2</span> <span class=mi>3</span><span class=p>)</span>
  <span class=p>(</span><span class=nb>list </span><span class=mi>4</span> <span class=mi>5</span> <span class=mi>6</span><span class=p>))</span>
  
<span class=nv>=&gt;</span> <span class=p>([</span><span class=mi>1</span>, <span class=mi>2</span>, <span class=mi>3</span>, <span class=mi>4</span>, <span class=mi>5</span>, <span class=mi>6</span><span class=p>])</span>
</code></pre></div><p>The real power of lists comes out when used with recursion where they are applied as a list of arguments. See the <code>apply</code> function.</p>
<h3 id=-operator><code>:</code> Operator</h3>
<p>The short form of cons is the <code>:</code> operator. It is used the same as above.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=err>:</span> <span class=mi>1</span> <span class=p>[</span><span class=mi>2</span> <span class=mi>3</span><span class=p>])</span>
<span class=nv>=&gt;</span> <span class=p>[[</span><span class=mi>1</span>, <span class=mi>2</span>, <span class=mi>3</span><span class=p>]]</span>
</code></pre></div><h2 id=the--operator-and-the-apply-function>The <code>&</code> Operator and the <code>apply</code> Function</h2>
<p>The <code>apply</code> function is a powerful function that allows us to expand a list as arguments for a function. It accepts the function as the first argument and a list of values-as-parameters as the second argument.</p>
<p>An example using the <code>+</code> operator.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=c1>; The operation we want to perform</span>
<span class=p>(</span><span class=nb>+ </span><span class=mi>1</span> <span class=mi>2</span> <span class=mi>3</span><span class=p>)</span>
<span class=nv>=&gt;</span> <span class=mi>6</span>

<span class=p>(</span><span class=nb>apply + </span><span class=p>(</span><span class=nb>list </span><span class=mi>1</span> <span class=mi>2</span> <span class=mi>3</span><span class=p>))</span>
<span class=nv>=&gt;</span> <span class=mi>6</span>
</code></pre></div><p>In most cases, we want to operate on value individually. The <code>&</code> (capture) operator allows us to capture all remaining unnamed arguments as a list.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=k>def </span><span class=nv>cap_example</span> <span class=p>(</span><span class=k>fn </span><span class=p>[</span><span class=nb>first </span><span class=o>&amp;</span> <span class=nv>rest</span><span class=p>]</span>
  <span class=p>(</span><span class=k>do </span><span class=p>(</span><span class=nf>inspect</span> <span class=s>&#34;First arg&#34;</span><span class=p>)</span>
      <span class=p>(</span><span class=nf>inspect</span> <span class=nv>first</span><span class=p>)</span>
      <span class=p>(</span><span class=nf>inspect</span> <span class=s>&#34;The rest of the args&#34;</span><span class=p>)</span>
      <span class=p>(</span><span class=nf>inspect</span> <span class=nv>rest</span><span class=p>))))</span>

<span class=nv>=&gt;</span> <span class=nv>&lt;#def</span> <span class=s>&#34;cap_example&#34;</span><span class=nv>&gt;</span>

<span class=p>(</span><span class=nf>cap_example</span> <span class=mi>1</span> <span class=mi>2</span> <span class=mi>3</span> <span class=mi>4</span> <span class=mi>5</span><span class=p>)</span> <span class=c1>; Calling the function</span>
<span class=nv>First</span> <span class=nv>arg</span>               <span class=c1>; inspecting first argument</span>
<span class=mi>1</span>
<span class=nv>The</span> <span class=nb>rest </span><span class=nv>of</span> <span class=nv>the</span> <span class=nv>args</span>    <span class=c1>; inspecting the remaining arguments</span>
<span class=p>([</span><span class=mi>2</span>, <span class=mi>3</span>, <span class=mi>4</span>, <span class=mi>5</span><span class=p>])</span>          

<span class=nv>=&gt;</span> <span class=p>([</span><span class=mi>2</span>, <span class=mi>3</span>, <span class=mi>4</span>, <span class=mi>5</span><span class=p>])</span>       <span class=c1>; Final return result of the function</span>
</code></pre></div><p>With recursion, it becomes even more powerful. The implementation of <code>max</code> shows how recursion, cons, apply, and & can be used together.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=k>def </span><span class=nb>max </span><span class=p>(</span><span class=k>fn </span><span class=p>[</span><span class=nv>a</span><span class=p>]</span> <span class=nv>a</span><span class=p>))</span>
<span class=p>(</span><span class=k>def </span><span class=nb>max </span><span class=p>(</span><span class=k>fn </span><span class=p>[</span><span class=nv>a</span> <span class=o>&amp;</span> <span class=nv>rest</span><span class=p>]</span>
  <span class=p>(</span><span class=k>let </span><span class=p>[</span><span class=nv>b</span> <span class=p>(</span><span class=nb>apply max </span><span class=nv>rest</span><span class=p>)]</span> 
    <span class=p>(</span><span class=k>if </span><span class=p>(</span><span class=nb>&gt;= </span><span class=nv>a</span> <span class=nv>b</span><span class=p>)</span> <span class=nv>a</span> <span class=nv>b</span><span class=p>))))</span>
</code></pre></div><h2 id=evaluating-code>Evaluating Code</h2>
<p>The <code>eval</code> function accepts a string and executes it as code. The return result is always <code>nil</code> but any functions or values bound to a name will be bound to the local scope.</p>
<p>A simple example using <code>inspect</code>:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nb>eval </span><span class=s>&#34;(def value 1)&#34;</span><span class=p>)</span>
<span class=nv>=&gt;</span> <span class=nv>&lt;#def</span> <span class=s>&#34;value&#34;</span><span class=nv>&gt;</span>

<span class=p>(</span><span class=nf>inspect</span> <span class=nv>value</span><span class=p>)</span>
<span class=mi>1</span>
<span class=nv>=&gt;</span> <span class=mi>1</span>
</code></pre></div><h3 id=complex-example>Complex Example</h3>
<p>A more complex example when you would want to eval code, is when the code is in another file or serialized into a string. The <code>import</code> function is implemented in Mylalang itself using only <code>eval</code> and <code>readfile</code>.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=k>def </span><span class=nb>import </span><span class=p>(</span><span class=k>fn </span><span class=p>[</span><span class=nv>file_name</span><span class=p>]</span> 
  <span class=p>(</span><span class=k>let </span><span class=p>[</span><span class=nv>contents</span> <span class=p>(</span><span class=nf>readfile</span> <span class=nv>file_name</span><span class=p>)]</span>
    <span class=p>(</span><span class=nb>eval </span><span class=nv>contents</span><span class=p>))))</span>
</code></pre></div><h2 id=native-functions>Native functions</h2>
<p>Most functions covered are implemented Mylalang itself. While there is no standard library, there are additional functions which come with Mylalang:</p>
<h3 id=foldl><code>foldl</code></h3>
<p><em>Note: This is an incorrect implementation. It should accept a list. Will be fixed in later versions.</em></p>
<p>Reduces an array of values to the left. Accepts a function in it&rsquo;s first position, accumulator in it&rsquo;s second.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nf>foldl</span> <span class=nb>+ </span><span class=mi>0</span> <span class=p>[</span><span class=mi>1</span> <span class=mi>2</span> <span class=mi>3</span> <span class=mi>4</span><span class=p>])</span>

<span class=mi>10</span>
</code></pre></div><h3 id=foldr><code>foldr</code></h3>
<p><em>Note: This is an incorrect implementation. It should accept a list. Will be fixed in later versions.</em></p>
<p>Reduces a list of values to the right. Accepts a function in it&rsquo;s first position, accumulator in it&rsquo;s second.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nf>foldr</span> <span class=nb>+ </span><span class=mi>0</span> <span class=p>[</span><span class=mi>1</span> <span class=mi>2</span> <span class=mi>3</span> <span class=mi>4</span><span class=p>])</span>

<span class=mi>10</span>
</code></pre></div><h3 id=min><code>min</code></h3>
<p>Returns the smallest value from a list.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nb>min </span><span class=mi>23</span> <span class=mi>77</span> <span class=mi>99</span><span class=p>)</span>

<span class=nv>=&gt;</span> <span class=mi>23</span>
</code></pre></div><h3 id=max><code>max</code></h3>
<p>Returns the largest value from a list.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nb>min </span><span class=mi>23</span> <span class=mi>77</span> <span class=mi>99</span><span class=p>)</span>

<span class=nv>=&gt;</span> <span class=mi>99</span>
</code></pre></div><h3 id=double><code>double</code></h3>
<p>Doubles a value! Originally implemented to provide a function to test with.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nb>double </span><span class=mi>21</span><span class=p>)</span>

<span class=nv>=&gt;</span> <span class=mi>42</span>
</code></pre></div><h3 id=map><code>map</code></h3>
<p>The <code>map</code> function maps a function over a list. Accepts a function as its first argument and a list for the remaining arguments.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-clojure data-lang=clojure><span class=p>(</span><span class=nb>map double </span><span class=mi>1</span> <span class=mi>2</span> <span class=mi>3</span> <span class=mi>4</span> <span class=mi>5</span><span class=p>)</span>

<span class=nv>=&gt;</span> <span class=p>([</span><span class=mi>2</span>, <span class=mi>4</span>, <span class=mi>6</span>, <span class=mi>8</span>, <span class=mi>10</span><span class=p>])</span>
</code></pre></div><p>More functions exist in the language which can be found by checking out the native <a href=https://github.com/APiercey/mylalang/tree/master/src/native>implementation files</a>.</p>
</div>
<div class=footer>
<div class=footer-social>
<span class="social-icon social-icon-github">
<a href=https://github.com/apiercey title=github target=_blank rel=noopener>
<img src=/images/social/github.svg width=24 height=24 alt=github>
</a>
</span>
<span class="social-icon social-icon-linkedin">
<a href=https://www.linkedin.com/in/alexander-butt-piercey title=linkedin target=_blank rel=noopener>
<img src=/images/social/linkedin.svg width=24 height=24 alt=linkedin>
</a>
</span>
</div>
</div>
</div>
<script type=text/javascript src=/js/bundle.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.js></script>
</body>
</html>